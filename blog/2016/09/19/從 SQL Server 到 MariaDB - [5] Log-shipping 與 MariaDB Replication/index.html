<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>從 SQL Server 到 MariaDB - [5] Log-shipping 與 MariaDB Replication | 隨意記事</title><link rel="stylesheet" type="text/css" href="/blog//css/normalize.css"><link rel="stylesheet" type="text/css" href="/blog//css/highlight.css"><link rel="stylesheet" type="text/css" href="/blog//css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
 google_ad_client: "ca-pub-0187888667607442",
 enable_page_level_ads: true
 });
</script></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/blog/." class="title">隨意記事</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/blog/" class="sidebar-nav-item">Home</a><a href="/blog/archives" class="sidebar-nav-item">Archives</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>從 SQL Server 到 MariaDB - [5] Log-shipping 與 MariaDB Replication</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2016-09-19</div><div class="post-tags"><a class="post-tag-link" href="/blog/tags/MSSQL/">MSSQL</a>/<a class="post-tag-link" href="/blog/tags/MariaDB/">MariaDB</a></div></div></div><article><div class="container post"><h2 id="需求說明"><a href="#需求說明" class="headerlink" title="需求說明"></a>需求說明</h2><p>在資料庫的備援部份，採用 SQL Server Log-shipping 方式來處理，希望在移轉至 MariaDB 時也有不錯的類似 Log-shipping 方式執行。</p>
<h2 id="MariaDB-Replication-uses-GTID"><a href="#MariaDB-Replication-uses-GTID" class="headerlink" title="MariaDB Replication uses GTID"></a>MariaDB Replication uses GTID</h2><p>接下來的文章來自於許多的文件，從<a href="https://mariadb.com/kb/en/mariadb/gtid/" target="_blank" rel="noopener">官方文件</a>，<a href="http://mysql.taobao.org/monthly/2016/02/08/" target="_blank" rel="noopener">MariaDB · 版本特性 · MariaDB 的 GTID 介绍</a>，還有<a href="https://segmentfault.com/a/1190000000598062" target="_blank" rel="noopener">mariadb10 GTID 研究笔记. md</a>與<a href="https://segmentfault.com/a/1190000000601849" target="_blank" rel="noopener">實作</a>，整理了一下。</p>
<h3 id="Master-與-Slave"><a href="#Master-與-Slave" class="headerlink" title="Master 與 Slave"></a>Master 與 Slave</h3><p>與 SQL Server Log-shipping 不一樣的地方如下</p>
<ol>
<li>不管什麼樣的 Replication (樹狀或是環型串聯)，發動端皆是 <b>Slave</b>，也就是說 Master 不存放任何有關 Replication 的資料，所有資料皆在 Slave 裡。</li>
<li>在 Primary Database (Master) 會是 Backup Trasnsaction 的動作，而在 Secondary Database (Slave) 是 Copy 與 Restore 的動作，在 MariaDB Replication 只會在 Slave 連到 Master 時看要複製哪一段的 binlog 加以重現。</li>
<li>因為 GTID 的設計，一個 Slave 的 Master 可以是多個，當然一個 Master 可以有多個 Slave。</li>
<li>Slave 重現完資料以後就會繼續跟 Master 要進一步的 binlog 資料，所以基本上是沒有落差可言的，在 SQL Server Log-shipping 是有發動時間設定的(預設為 15 分鐘)。</li>
<li>系統的資料庫 (mysql 那些)也可以做 Replication。</li>
</ol>
<p>在 4 的部份，其實對於現在的維運有些麻煩。因為這 15 分鐘的落差，可以拿來利用成正式環境的 buffer，下錯指令時如果還在 15 分鐘的時間分隔下，還可以趕快去備援區拿資料蓋回去，現在沒有時間設定的話就比較麻煩。有人發個 <a href="https://jira.mariadb.org/browse/MDEV-7145" target="_blank" rel="noopener">issue</a> 希望能 merge MySQL 的 <code>MASTER_DELAY</code> 功能，不過表定是 10.2.x 的功能，希望能實作在 10.1.x。</p>
<p>在 5 的部份我覺得還蠻方便的就是帳號密碼的同步，在 SQL Server Log-shipping 是要分開想辦法同步的，管理就很方便了。</p>
<h3 id="Slave-如何透過-GTID-做-Replication"><a href="#Slave-如何透過-GTID-做-Replication" class="headerlink" title="Slave 如何透過 GTID 做 Replication"></a>Slave 如何透過 GTID 做 Replication</h3><p>GTID 的規格部份就不解釋了，上面的文件寫的很清楚。</p>
<p>在 MariaDB 有一些 Server Variables 紀錄 GTID 的資訊</p>
<table>
<thead>
<tr>
<th>Server Variables Names</th>
<th>意義</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>gtid_binlog_pos</code></td>
<td>binlog 裡最後一筆紀錄的  GTID</td>
</tr>
<tr>
<td><code>gtid_slave_pos</code></td>
<td>Slave 上紀錄的最後一個 binlog GTID</td>
</tr>
<tr>
<td><code>gtid_current_pos</code></td>
<td>Database 上紀錄的最後一個 binlog GTID</td>
</tr>
</tbody>
</table>
<p>什麼叫作 “紀錄的最後一個 binlog GTID” 呢?</p>
<p>對 <code>gtid_slave_pos</code> 來說，就是 master 的最後一筆 GTID。</p>
<p>對 <code>gtid_current_pos</code> 來說，不管當下的 Instance 之前是 Master 還是 Slave</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><p></p>
<pre><code>if gtid_binlog_pos.ServerID = Instance.ServerID and gtid_binlog_pos.DomainID = Instance.DomainID and gtid_binlog_pos.SequenceID &gt; gtid_slave_pos.SequenceID (同 ServerID 與 DomainID 狀態下) then
  gtid_current_pos = gtid_binlog_pos
else 
  gtid_current_pos = gtid_slave_pos (同 ServerID 與 DomainID 狀態下)
end if
</code></pre><p>官方文件有說到一個例子，假設 A 為 Master，B 為 Slave，參數為 <code>slave_pos</code>，把 A 先關一會兒，讓 B 成為 Master，最後回復 A 並成為 B 的 Slave。</p>
<p><img src="https://raw.githubusercontent.com/sujunmin/sujunmin.github.com/master/test/MariaDB_Replication_1.png"></p>
<ul>
<li>一開始 A 的 <code>gtid_binlog_pos</code> 與 <code>gtid_current_pos</code> 相同（<code>1-1-123</code>, <code>1-1-137</code>, <code>1-1-145</code>），<code>gtid_slave_pos</code> 是空值。</li>
<li>B 的 <code>gtid_slave_pos</code> 記著 A 的最後一個 GTID。</li>
<li>在 A 的 <code>1-1-145</code> 的時候把 A 先關掉，中間 B 的修改先忽略不看(假設沒發生)，現在資料庫停在 <code>1-1-145</code>。</li>
<li>在 A 恢復以後，設定 A 為 B 的 Slave，但是這個時候的 <code>gtid_slave_pos</code> 是空值，所以設成 <code>current_pos</code> (就是 <code>1-1-145</code>)。</li>
<li>到 B 的 <code>1-1-147</code> 的時候，最新的就是 <code>1-1-147</code>，B 就知道怎麼恢復了 (<code>145</code>-<code>147</code>)，正式加成 A 的 Slave。</li>
</ul>
<p>這個的假設前提是在那個中斷時間內沒 B 沒有任何的 binlog 紀錄交易，這樣能確保 <code>1-1-145</code> 到 <code>1-1-147</code> 都只有在有 Slave 的狀態下 Master 產生的交易，假設 B 中間原來忽略的的 <code>2-2-138</code> 被產生了，那麼 binlog 的順序就會在 <code>1-1-145</code> 與 <code>1-1-147</code> 中間夾一個 <code>2-2-138</code>，奇怪的交易紀錄，會導致 A 的加入失敗。</p>
<p>所以官方建議在 Slave 上不要有任何的 binlog 紀錄 (Session 中 <code>@@sql_log_bin=0</code>)，避免當這個 Slave 有機會變成 Master 或是再 Slave 到其他地方時有交易紀錄異常的問題。</p>
<p>如果還是要修改 Slave 的資料造成 binlog 會有變動，還是要把參數設為 <code>slave_pos</code>，確保 Slave 會從 Master 看的 binlog 資料不會因為 Slave 的變動而異常，不能像 <code>current_pos</code> 那樣兩邊都有可能取值，不管是什麼角色。</p>
<p>在 B 當 Slave 的時候如果沒有開 binlog，那麼 <code>current_pos</code> 與 <code>slave_pos</code> 是同一件事，當然後續的切換是不會發生的 (B 沒 binlog 不能當 Master)。</p>
<h2 id="最後的設計"><a href="#最後的設計" class="headerlink" title="最後的設計"></a>最後的設計</h2><p>剛剛最後有說到在 Slave 沒有開 binlog 的方式，我原來是想要用這個的，因為這蠻像現在的維運模式。</p>
<ol>
<li>當 Master 壞了就停掉 Slave 的 Service</li>
<li>等到 Master 好的時候停機備份到 Master 上</li>
<li>在 Slave 重新建 Replication</li>
</ol>
<p>如果 Slave 有開 binlog，第2步的停機備份似乎可以把時間縮短</p>
<ol>
<li>當 Master 壞了就停掉 Slave 的 Service</li>
<li>等到 Master 好的時候倒回 Slave 的備份</li>
<li>同步完成後重新建立 Master / Slave 順序 </li>
</ol>
<h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><h3 id="在同一個機器上開新的-Instance"><a href="#在同一個機器上開新的-Instance" class="headerlink" title="在同一個機器上開新的 Instance"></a>在同一個機器上開新的 Instance</h3><ul>
<li><p>有一個不錯用的工具 <a href="https://mariadb.com/kb/en/mariadb/mysql_install_dbexe/" target="_blank" rel="noopener">mysql_install_db.exe</a> 可以直接開新的 Instance。</p>
<p>我們用這個先開一個 Instance 在 Port 3307。</p>
</li>
<li><p>設定原來在 3306 的為 Master (<code>server-id=1</code>)，3307 的為 Slave (<code>server-id=2</code>)，都開啟 binlog (<code>log-bin</code>)。 </p>
</li>
<li>Event 記得設成 Disabled on Slave。</li>
<li>接下來備份 Master</li>
</ul>
<p></p><p class="code-caption" data-lang="cmd" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><p></p>
<pre><code class="cmd">E:\backup&gt;mysqldump -u sujunmin -p --master-data --all-databases --events --routines --gtid &gt; all_db.sql
Enter password: ************
</code></pre>
<p>  其中幾個重要參數</p>
<table>
<thead>
<tr>
<th>參數</th>
<th>意義</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>master-data</code></td>
<td>dump 出來的掛 master ID</td>
</tr>
<tr>
<td><code>events</code></td>
<td>包含 events</td>
</tr>
<tr>
<td><code>routines</code></td>
<td>包含 functions 與 store procedures</td>
</tr>
<tr>
<td><code>gtid</code></td>
<td>產生 <code>CHANGE MASTER TO master_use_gtid</code> 語法</td>
</tr>
</tbody>
</table>
<p>  觀察一下 <code>all_db.sql</code> 的內容</p>
<p></p><p class="code-caption" data-lang="sql" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><p></p>
<pre><code class="sql">-- MySQL dump 10.16  Distrib 10.1.17-MariaDB, for Win64 (AMD64)
(中間省略)
--
-- Position to start replication or point-in-time recovery from
--

-- CHANGE MASTER TO MASTER_LOG_FILE=&#39;WSTest-bin.000002&#39;, MASTER_LOG_POS=3732;

--
-- GTID to start replication from
--

CHANGE MASTER TO MASTER_USE_GTID=slave_pos;
SET GLOBAL gtid_slave_pos=&#39;0-1-770&#39;;

--
-- Current Database: &#39;master&#39;
--
(後面省略)
</code></pre>
<p>  可以看到如果要用舊的方式(兼容 MySQL Replication) 與新的方式。</p>
<ul>
<li>啟動 Slave 的 Instance。  </li>
<li>把 <code>all_db.sql</code> 倒到 Slave (3307) 上面。</li>
<li>在 Master 上開一個 User <code>lsuser</code> 作為 Replication 用，權限是 <code>REPLICATION SLAVE</code> 與 <code>SUPER</code> (這個我不設定會沒權限登入，但是官方網站沒有這個權限)。</li>
<li>在 Slave 上設定 <code>CHANGE MASTER</code> </li>
</ul>
<p></p><p class="code-caption" data-lang="cmd" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><p></p>
<pre><code class="cmd">MariaDB [(none)]&gt; change master to master_host=&#39;localhost&#39;, master_port=3306, master_user=&#39;lsuser&#39;, master_password=&#39;password&#39;;
Query OK, 0 rows affected (0.05 sec)
</code></pre>
<ul>
<li><code>START SLAVE;</code></li>
<li><code>SHOW SLAVE STATUS;</code></li>
</ul>
<p></p><p class="code-caption" data-lang="cmd" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><p></p>
<pre><code class="cmd">MariaDB [(none)]&gt; show slave status\G
*************************** 1. row ***************************
            Slave_IO_State: Waiting for master to send event
               Master_Host: localhost
               Master_User: lsuser
               Master_Port: 3306
             Connect_Retry: 60
           Master_Log_File: WSTest-bin.000002
       Read_Master_Log_Pos: 5429
            Relay_Log_File: WSTest-relay-bin.000002
             Relay_Log_Pos: 5757
     Relay_Master_Log_File: WSTest-bin.000002
          Slave_IO_Running: Yes
         Slave_SQL_Running: Yes
           Replicate_Do_DB:
                        (省略)
                Using_Gtid: Slave_Pos
               Gtid_IO_Pos: 0-1-775
   Replicate_Do_Domain_Ids:
 Replicate_Ignore_Domain_Ids:
             Parallel_Mode: conservative
 1 row in set (0.00 sec)
</code></pre>
<ul>
<li>看一下同步狀況</li>
<li>移除 Master 模擬 Master 壞掉了狀態<ul>
<li><code>sc stop mariadb</code></li>
<li><code>sc delete mariadb</code></li>
<li>移除資料</li>
</ul>
</li>
<li>Slave 沒法連到 Master 了</li>
</ul>
<p></p><p class="code-caption" data-lang="cmd" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><p></p>
<pre><code class="cmd">MariaDB [(none)]&gt; show slave status\G
*************************** 1. row ***************************
             Slave_IO_State: Reconnecting after a failed master event read
                Master_Host: localhost
                Master_User: lsuser
                Master_Port: 3306
              Connect_Retry: 60
            Master_Log_File: WSTest-bin.000002
        Read_Master_Log_Pos: 8223
             Relay_Log_File: WSTest-relay-bin.000002
              Relay_Log_Pos: 8551
      Relay_Master_Log_File: WSTest-bin.000002
           Slave_IO_Running: Connecting
          Slave_SQL_Running: Yes
                         (省略)
              Last_IO_Errno: 2003
              Last_IO_Error: error reconnecting to master &#39;lsuser@localhost:3306&#39; - retry-time: 60  retries: 86400  message: Can&#39;t connect to MySQL server on&#39;localhost&#39; (10061 &quot;Unknown error&quot;)
             Last_SQL_Errno: 0
             Last_SQL_Error:
 Replicate_Ignore_Server_Ids:
           Master_Server_Id: 1
             Master_SSL_Crl:
         Master_SSL_Crlpath:
                 Using_Gtid: Slave_Pos
                Gtid_IO_Pos: 0-1-784
    Replicate_Do_Domain_Ids:
 Replicate_Ignore_Domain_Ids:
              Parallel_Mode: conservative
 1 row in set (0.00 sec)
</code></pre>
<ul>
<li><code>STOP SLAVE</code></li>
<li>打開 Slave 的 Event 服務</li>
<li>繼續服務</li>
<li>重建 Master</li>
</ul>
<p></p><p class="code-caption" data-lang="cmd" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><p></p>
<pre><code class="cmd">E:\backup&gt;mysqldump -u sujunmin -p --port 3307 --master-data --all-databases --events --routines --gtid &gt; all_db.sql
Enter password: ************
</code></pre>
<p>  觀察一下 <code>all_db.sql</code> 的內容</p>
<p></p><p class="code-caption" data-lang="sql" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><p></p>
<pre><code class="sql">-- MySQL dump 10.16  Distrib 10.1.17-MariaDB, for Win64 (AMD64)
(中間省略)
--
-- Position to start replication or point-in-time recovery from
--

-- CHANGE MASTER TO MASTER_LOG_FILE=&#39;WSTest-bin.000003&#39;, MASTER_LOG_POS=12441;

--
-- GTID to start replication from
--

CHANGE MASTER TO MASTER_USE_GTID=slave_pos;
SET GLOBAL gtid_slave_pos=&#39;0-2-976&#39;;

--
-- Current Database: &#39;master&#39;
--
(後面省略)
</code></pre>
<ul>
<li>啟動 Master 的 Instance。  </li>
<li>把 <code>all_db.sql</code> 倒到 Master (3307) 上面。</li>
<li>在 Slave 上設定 <code>CHANGE MASTER</code> 為 <code>current_pos</code> </li>
</ul>
<p></p><p class="code-caption" data-lang="cmd" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><p></p>
<pre><code class="cmd">MariaDB [(none)]&gt; change master to master_host=&#39;localhost&#39;, master_port=3306, master_user=&#39;lsuser&#39;, master_password=&#39;password&#39;, master_use_gtid=current_pos;
Query OK, 0 rows affected (0.05 sec)
</code></pre>
<ul>
<li><code>START SLAVE;</code></li>
<li><code>SHOW SLAVE STATUS;</code></li>
</ul>
<p></p><p class="code-caption" data-lang="cmd" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><p></p>
<pre><code class="cmd">MariaDB [(none)]&gt; show slave status\G
  *************************** 1. row ***************************
                          (省略)
             Last_IO_Errno: 1236
             Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: &#39;Error: connecting slave requested to start from GTID 0-2-980, which is not in the master&#39;s binlog. Since the master&#39;s binlog contains GTIDs with higher sequence numbers, it probably means that the slave has diverged due to executing extra erroneous transactions&#39;
            Last_SQL_Errno: 0
            Last_SQL_Error:
Replicate_Ignore_Server_Ids:
          Master_Server_Id: 1
            Master_SSL_Crl:
        Master_SSL_Crlpath:
                Using_Gtid: Current_Pos
               Gtid_IO_Pos: 0-2-980
   Replicate_Do_Domain_Ids:
Replicate_Ignore_Domain_Ids:
              Parallel_Mode: conservative
  1 row in set (0.00 sec)
</code></pre>
<ul>
<li><code>STOP SLAVE;</code></li>
<li>在 Slave 上設定 <code>CHANGE MASTER</code> 為 <code>slave_pos</code>   </li>
</ul>
<p></p><p class="code-caption" data-lang="cmd" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><p></p>
<pre><code class="cmd">MariaDB [(none)]&gt; change master to master_host=&#39;localhost&#39;, master_port=3306, master_user=&#39;lsuser&#39;, master_password=&#39;password&#39;, master_use_gtid=slave_pos;
Query OK, 0 rows affected (0.05 sec)
</code></pre>
<ul>
<li><code>START SLAVE;</code></li>
<li><code>SHOW SLAVE STATUS;</code></li>
</ul>
<p></p><p class="code-caption" data-lang="cmd" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><p></p>
<pre><code class="cmd">MariaDB [(none)]&gt; show slave status\G
*************************** 1. row ***************************
            Slave_IO_State: Waiting for master to send event
               Master_Host: localhost
               Master_User: lsuser
               Master_Port: 3306
             Connect_Retry: 60
           Master_Log_File: WSTest-bin.000003
       Read_Master_Log_Pos: 7177
            Relay_Log_File: WSTest-relay-bin.000003
             Relay_Log_Pos: 7466
     Relay_Master_Log_File: WSTest-bin.000003
          Slave_IO_Running: Yes
         Slave_SQL_Running: Yes
                        (省略)
                Using_Gtid: Slave_Pos
               Gtid_IO_Pos: 0-1-1167
   Replicate_Do_Domain_Ids:
 Replicate_Ignore_Domain_Ids:
               Parallel_Mode: conservative
1 row in set (0.00 sec)
</code></pre>
<ul>
<li>這兩個對應 (<code>0-2-976</code>, <code>0-1-1167</code>) 都幫你做好了</li>
<li><p>完成</p>
<h2 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h2></li>
<li>如果是 Multi-Master 的這個系統會很好做 (<code>CREATE MASTER to ..., master_use_gtid=slave_pos;</code>)，因為 <code>slave_pos</code> 可以是多個的，例如 <code>gtid_slave_pos=&#39;0-1-123,1-2-456,...&#39;</code></li>
<li>Slave 如果要快速完復，不需要備份還原的話，那麼就只能當 Snapshot 來用 (不能動他讓他產生自己的 binlog)</li>
<li><p>對於原來的需求 (單一 Master 單一 Slave) 基本上設定一下就完成了</p>
<h2 id="上線紀錄"><a href="#上線紀錄" class="headerlink" title="上線紀錄"></a>上線紀錄</h2><h3 id="2016-11-8"><a href="#2016-11-8" class="headerlink" title="2016/11/8"></a>2016/11/8</h3><p>有時候會碰到有些指令沒法傳過去的問題(如建立 FederatedX Table)，這時候 Slave 會卡在 Error 的地方不能過去，所以要手動 bypass 它。</p>
<p>但是不太清楚要 skip 幾個的狀態下，就一個一個看了。</p>
</li>
</ul>
<p></p><p class="code-caption" data-lang="sql" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><p></p>
<pre><code class="sql">stop slave;
set global sql_slave_skip_counter=1;
start slave;

select sleep(10);

show slave status;
</code></pre>
</div><!-- comment system--><div class="container"><hr><div id="disqus_thread"></div><script type="text/javascript">
var disqus_shortname = 'sujunmin';
var disqus_identifier = '2016/09/19/從 SQL Server 到 MariaDB - [5] Log-shipping 與 MariaDB Replication/';
var disqus_title = '從 SQL Server 到 MariaDB - [5] Log-shipping 與 MariaDB Replication';
var disqus_url = 'https://sujunmin.github.io/blog/2016/09/19/從 SQL Server 到 MariaDB - [5] Log-shipping 與 MariaDB Replication/';
(function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">Blog comments powered by <span class="logo-disqus">Disqus</span></a></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="http://twitter.com/sujunmin_" target="_blank"><i class="fa fa-twitter"></i></a><a href="https://github.com/sujunmin" target="_blank"><i class="fa fa-github"></i></a><a href="https://plus.google.com/+JunMingSu" target="_blank"><i class="fa fa-google-plus"></i></a><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2018 <a href="/" rel="nofollow">隨意記事</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-78894509-1');ga('send','pageview');</script></body></html>